const { default: axios } = require('axios');
const PlaylistModel = require('../models/knex/Playlist');
const TrackModel = require('../models/knex/Track');
const LabelModel = require('../models/knex/Label');
const TracksService = require('./tracks');
const { chunkArray } = require('../utils');

const request = require('request-promise-native');
const PlaylistModel1 = require('../models/Playlist');
const TrackModel1 = require('../models/Track');
const LabelModel1 = require('../models/Label');

/**
 * - Add tracks to Spotify playlists
 * - Add Track-Playlist associations in our database
 * - Update Playlists with new info
 * @param {UserObj} userObj
 * @param {PlaylistTrackIds[]} data
 */
exports.addTracks = async (userObj, data) => {
  // Spotify: add tracks to playlists in parallel
  const spotifyRequests = data.map(playlistTracks =>
    updateSpotifyPlaylistTracks(userObj, playlistTracks)
  );
  // Get back new snapshot_ids and track_count_delta
  const playlistUpdates = await Promise.all(spotifyRequests);
  // Add associations to our database
  await PlaylistModel.addPlaylists(userObj.userId, data);
  // Update playlists with new info
  await PlaylistModel.updateMany(playlistUpdates);
};
/**
 * - Remove tracks from Spotify playlists
 * - Remove Track-Playlist associations in our database
 * - Update Playlists with new info
 * @param {UserObj} userObj
 * @param {PlaylistTrackIds[]} data
 */
exports.removeTracks = async (userObj, data) => {
  // Spotify: remove tracks to playlists in parallel
  const spotifyRequests = data.map(playlistTracks =>
    updateSpotifyPlaylistTracks(userObj, playlistTracks, true)
  );
  // Get back new snapshot_ids and track_count_delta
  const playlistUpdates = await Promise.all(spotifyRequests);
  // Remove associations from our database
  await PlaylistModel.removePlaylists(data);
  // Update playlists with new info
  await PlaylistModel.updateMany(playlistUpdates);
};

/**
 * Create Spotify and MoodMusic playlist.
 * @param {UserObj} userObj
 * @param {NewPlaylist} data
 * @returns {Promise<object>} Created playlist
 */
exports.create = async (userObj, data) => {
  // Handle playlists auto-generated from labels
  if (!data.name && data.type === 'label') {
    const label = await LabelModel.get(userObj.userId, data.label_id);
    data.name = `< ${label.name} >`;
    data.description = `Playlist generated by MoodMusic, associated with\
    ${label.type} label: < ${label.name} >`;
  }
  // Create Spotify playlist and handle response data
  const { data: resData } = await axios.post(
    `https://api.spotify.com/v1/users/${userObj.userId}/playlists`,
    { name: data.name, description: data.description },
    { headers: { Authorization: `Bearer ${userObj.accessToken}` } }
  );
  data.id = resData.id;
  data.snapshot_id = resData.snapshot_id;
  // Add label's existing tracks to Spotify playlist
  if (data.type === 'label') {
    const trackIds = await LabelModel.getTrackIds(data.label_id);
    const playlistTrackIds = { playlist_id: resData.id, track_ids: trackIds };
    if (trackIds.length) {
      const {
        snapshot_id,
        track_count_delta,
      } = await updateSpotifyPlaylistTracks(userObj, playlistTrackIds);
      data.snapshot_id = snapshot_id;
      data.track_count = track_count_delta;
    }
    const playlist = await PlaylistModel.create(userObj.userId, data);
    await PlaylistModel.addPlaylists(userObj.userId, [playlistTrackIds]);
    return playlist;
  }

  return PlaylistModel.create(userObj.userId, data);
};
/**
 *
 * @param {UserObj} userObj
 * @param {string} id - playlistId
 * @param {PlaylistUpdates} data
 */
exports.update = async (userObj, id, data) => {
  /**
   * - EXTRA: removeDupes here???
   * - get playlist (type, label_id)
   * - handle type changes
   * - spotify request for name/description change
   */
  const { type, label_id } = await PlaylistModel.getOne(userObj.userId, id);

  // Changing the playlist type comes with multiple side-effects
  if (data.type) {
    // Handle changes on existing label playlist
    if (type === 'label') {
      if (data.type === 'label' && data.label_id) {
        // Remove old label from playlist's tracks
        //// await LabelModel.removeLabelTracks(label_id)
      } else {
        // Remove playlist-label assoc; keep label-tracks assoc
        data.label_id = null;
      }
    }

    if (data.type === 'untracked') {
      // Remove playlist-tracks assoc; keep user-tracks
      //// await PlaylistModel.removePlaylistTracks
    } else {
      // Unless setting playlist to 'untracked', syncTracks
      exports.syncTracks(userObj, id, {
        type: data.type,
        label_id: data.label_id,
      });
      if (data.type === 'label') {
        // TODO!! what if playlist contains tracks with label
        // will there be duplicates after spotify req??
        const trackIds = await LabelModel.getTrackIds(data.label_id);
        if (trackIds.length) {
          const playlistTrackIds = {
            playlist_id: id,
            track_ids: trackIds,
          };
          const playlistChanges = await updateSpotifyPlaylistTracks(
            userObj,
            playlistTrackIds
          );
          data.snapshot_id = playlistChanges.snapshot_id;
          data.track_count_delta = playlistChanges.track_count_delta;
          await PlaylistModel.addPlaylists(userObj.userId, [playlistTrackIds]);
        }
        // Add tracks from label_id (label_id might have extra tracks not added)
        //  updateSpotifyPlaylistTracks
        //    update snapshot_id and track_count
        //  PlaylistModel.addPlaylists
      }
    }
  }

  // Spotify request to change name and/or description
  if (data.name || data.description) {
    await axios.put(
      `https://api.spotify.com/v1/playlists/${id}`,
      {
        ...(data.name && { name: data.name }),
        ...(data.description && { description: data.description }),
      },
      { headers: { Authorization: `Bearer ${userObj.accessToken}` } }
    );
  }

  // TODO? set updates=false if we synced
  return PlaylistModel.update(userObj.userId, id, data);
};

exports.update1 = async (userObj, id, data) => {
  const { type, label_id } = await PlaylistModel1.getOne(id);

  // Changing the playlist type comes with multiple side-effects
  switch (data.type) {
    case 'untracked': {
      if (type === 'label') {
        // Remove playlist-label assoc
        data.label_id = null;
      }
      // Remove playlist-tracks associations (but leave tracks)
      await PlaylistModel1.removePlaylistTracks(id);
      break;
    }
    case 'mix': {
      const tracks = await TracksService.getPlaylistTracks(userObj, id, true);
      if (type === 'label') {
        // Remove playlist-label assoc
        data.label_id = null;
      }
      // sync/import
      await TrackModel1.addTracks(tracks);
      await PlaylistModel1.addPlaylists([{ playlist_id: id, tracks }], true);
      break;
    }
    case 'label': {
      const tracks = await TracksService.getPlaylistTracks(id, true);
      if (type === 'label' && data.label_id) {
        // Remove prev label from tracks and add new one
        await LabelModel1.removeLabelTracks(label_id);
      }
      // sync/import
      await TrackModel1.addTracks(tracks);
      await PlaylistModel1.addPlaylists([{ playlist_id: id, tracks }], true);
      await LabelModel1.addLabels([
        { label_id: data.label_id, track_ids: tracks.map(t => t.id) },
      ]);

      // Add all tracks with label_id (not in playlist) to playlist
      const labelTracks = await LabelModel1.getTracks(data.label_id);
      if (labelTracks.length) {
        const newPlaylistTracks = {
          playlist_id: id,
          track_ids: labelTracks,
        };
        const [snapshotId, newTrackCount] = await addPlaylistTracks(
          userObj,
          newPlaylistTracks
        );
        data.snapshot_id = snapshotId;
        data.track_count = newTrackCount;
        await PlaylistModel1.addPlaylists([newPlaylistTracks], true);
      }
      break;
    }
  }
  // Spotify request
  if (data.name || data.description) {
    await request.put({
      url: 'https://api.spotify.com/v1/playlists/' + id,
      headers: { Authorization: 'Bearer ' + userObj.accessToken },
      body: {
        ...(data.name && { name: data.name }),
        ...(data.description && { description: data.description }),
      },
      json: true,
    });
  }
  return PlaylistModel1.update(id, data);
};
exports.delete = async (userObj, id) => {
  await request.delete({
    url: 'https://api.spotify.com/v1/playlists/' + id + '/followers',
    headers: { Authorization: 'Bearer ' + userObj.accessToken },
    json: true,
  });
  await PlaylistModel1.removePlaylistTracks(id);
  await PlaylistModel1.updateMany([{ id, type: 'deleted', label_id: null }]);

  return PlaylistModel1.getOne(id);
};
exports.restore = async (userObj, id) => {
  await request.put({
    url: 'https://api.spotify.com/v1/playlists/' + id + '/followers',
    headers: { Authorization: 'Bearer ' + userObj.accessToken },
    json: true,
  });
  await PlaylistModel1.updateMany([{ id, type: 'untracked' }]);
  // TODO: remove this and put it in track controller
  return PlaylistModel1.getOne(id);
};

/**
 * Sync a playlist to match it's Spotify state.
 * Pass updateData to sync when updating playlist type.
 * @param {UserObj} userObj
 * @param {string} id - playlistId
 * @param {object} [updateData] - Sync for playlist type update.
 * @param {string} updateData.type
 * @param {number} updateData.label_id
 */
exports.syncTracks = async (userObj, id, updateData = undefined) => {
  const { type, label_id } =
    updateData || (await PlaylistModel.getOne(userObj.userId, id));

  // Import tracks from untracked playlist (only add tracks)
  // OR add new tracks when updates = TRUE
  const tracks = await TracksService.getPlaylistTracks(userObj, id);
  await TrackModel.addTracks(userObj.userId, tracks);
  if (['mix', 'label'].includes(type)) {
    // Add new playlist-track associations
    const playlistTracks = { playlist_id: id, tracks };
    await PlaylistModel.addPlaylists(userObj.userId, [playlistTracks], true);
    if (type === 'label') {
      // TODO? remove all labels before readding?
      // if user removes track from spotifyPL, should we remove label from track?
      // ??? maybe add syncing to addLabels
      const trackIds = tracks.map(t => t.id);
      await LabelModel.syncPlaylistLabels(id, label_id, trackIds);
    }
  }
  // Playlist synced, set updates to false
  // TODO? dont update here if we have cachedData (it means we're not done)
  await PlaylistModel.update(userObj.userId, id, { updates: false });
};

exports.syncTracks1 = async (userObj, id) => {
  const { type, label_id } = await PlaylistModel1.getOne(id);
  const tracks = await TracksService.getPlaylistTracks(userObj, id);

  const associations = [
    {
      playlist_id: id,
      tracks,
      ...(label_id && {
        label_id: label_id,
        track_ids: tracks.map(t => t.id),
      }),
    },
  ];
  await TrackModel1.addTracks(tracks);
  if (type !== 'untracked') {
    await PlaylistModel1.addPlaylists(associations, true);
    if (type === 'label') {
      await LabelModel1.removeLabelTracks(label_id);
      await LabelModel1.addLabels(associations);
    }
  }
  await PlaylistModel1.updateMany([{ id, updates: 0 }]);
  return PlaylistModel1.getOne(id);
};
exports.revertTracks = async (userObj, playlistId) => {
  const trackIds = await PlaylistModel1.getTracks(playlistId);
  let uris = trackIds.map(id => 'spotify:track:' + id);

  let replace = true; // first 100 tracks use the replace endpoint
  let snapshotId;
  while (uris.length) {
    const batch = uris.splice(0, 100);
    const options = {
      url: 'https://api.spotify.com/v1/playlists/' + playlistId + '/tracks',
      headers: { Authorization: 'Bearer ' + userObj.accessToken },
      body: { uris: batch },
      json: true,
    };
    if (replace) {
      const response = await request.put(options);
      snapshotId = response.snapshot_id;
      replace = false;
    } else {
      const response = await request.post(options);
      snapshotId = response.snapshot_id;
    }
  }
  await PlaylistModel1.updateMany([
    {
      id: playlistId,
      updates: 0,
      track_count: trackIds.length,
      snapshot_id: snapshotId,
    },
  ]);
  return PlaylistModel1.getOne(playlistId);
};

// Helpers
/**
 * Handle adding/removing tracks in Spotify playlist.
 * @param {UserObj} userObj
 * @param {PlaylistTrackIds} data
 * @param {boolean=} remove - Default false, pass true to reverse operation.
 * @returns {Promise<PlaylistChanges>}
 */
const updateSpotifyPlaylistTracks = async (
  userObj,
  { playlist_id, track_ids },
  remove = false
) => {
  const trackUris = track_ids.map(id => `spotify:track:${id}`);
  const url = `https://api.spotify.com/v1/playlists/${playlist_id}/tracks`;
  const headers = {
    Authorization: 'Bearer ' + userObj.accessToken,
  };
  let snapshot_id;
  const chunks = chunkArray(trackUris, 100);
  for (const chunk of chunks) {
    const { data } = await axios({
      url,
      method: remove ? 'delete' : 'post',
      data: { uris: chunk },
      headers,
    });
    snapshot_id = data.snapshot_id;
  }
  // TODO! snapshot_id might be undefined (v2 had a check for this)
  return {
    id: playlist_id,
    snapshot_id,
    track_count_delta: track_ids.length * (remove ? -1 : 1),
  };
};
/**
 * Remove duplicate tracks from Spotify playlist.
 * @param {UserObj} userObj
 * @param {string} id - playlistId
 * @param {string[]=} trackIds - Optional, for avoiding more Spotify requests.
 */
const removePlaylistDuplicates = async (userObj, id, trackIds) => {
  // TODO!, use this when updating playlist to tracked or when syncing
  // a single playlist
  /**
   * - get dupe track_ids from array and then remove from playlist, and add again
   */
};
