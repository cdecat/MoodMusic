const { default: axios } = require('axios');
const PlaylistModel = require('../models/knex/Playlist');
const TrackModel = require('../models/knex/Track');
const LabelModel = require('../models/knex/Label');
const TracksService = require('./tracks');
const { chunkArray } = require('../utils');

const request = require('request-promise-native');
const PlaylistModel1 = require('../models/Playlist');
const TrackModel1 = require('../models/Track');
const LabelModel1 = require('../models/Label');

/**
 * - Add tracks to Spotify playlists
 * - Add Track-Playlist associations in our database
 * - Update Playlists with new info
 * @param {UserObj} userObj
 * @param {PlaylistTrackIds[]} data
 */
exports.addTracks = async (userObj, data) => {
  // Spotify: add tracks to playlists in parallel
  const spotifyRequests = data.map(playlistTracks =>
    updateSpotifyPlaylistTracks(userObj, playlistTracks)
  );
  // Get back new snapshot_ids and track_count_delta
  const playlistUpdates = await Promise.all(spotifyRequests);
  // Add associations to our database
  await PlaylistModel.addPlaylists(userObj.userId, data);
  // Update playlists with new info
  await PlaylistModel.updateMany(playlistUpdates);
};
/**
 * - Remove tracks from Spotify playlists
 * - Remove Track-Playlist associations in our database
 * - Update Playlists with new info
 * @param {UserObj} userObj
 * @param {PlaylistTrackIds[]} data
 */
exports.removeTracks = async (userObj, data) => {
  // Spotify: remove tracks to playlists in parallel
  const spotifyRequests = data.map(playlistTracks =>
    updateSpotifyPlaylistTracks(userObj, playlistTracks, true)
  );
  // Get back new snapshot_ids and track_count_delta
  const playlistUpdates = await Promise.all(spotifyRequests);
  // Remove associations from our database
  await PlaylistModel.removePlaylists(data);
  // Update playlists with new info
  await PlaylistModel.updateMany(playlistUpdates);
};

// =================== TODO: Playlist CRUD
exports.create = async (userObj, data) => {
  // handle auto-generated <Label Playlists>
  if (!data.name && data.type === 'label') {
    const label = await LabelModel1.getOne(data.label_id);
    data.name = `[ ${label.name} ]`;
    data.description =
      `Label playlist for [ ${label.name} ]. ` +
      `Auto-generated by MoodMusic (library management app).`;
  }
  const response = await request.post({
    url: 'https://api.spotify.com/v1/users/' + userObj.userId + '/playlists',
    headers: { Authorization: 'Bearer ' + userObj.accessToken },
    body: {
      name: data.name,
      description: data.description,
    },
    json: true,
  });

  const playlistData = {
    id: response.id,
    name: response.name,
    description: response.description,
    track_count: response.tracks.total,
    snapshot_id: response.snapshot_id,
    added_at: new Date().toISOString(),
    type: data.type,
    ...(data.type === 'label' && { label_id: data.label_id }),
  };
  // Add labelTracks to labelPlaylist
  if (data.type === 'label' && data.label_id) {
    const labelTracks = await LabelModel1.getTracks(data.label_id);
    const playlistTracks = {
      playlist_id: response.id,
      track_ids: labelTracks,
    };
    if (labelTracks.length) {
      const [snapshotId, newTrackCount] = await addPlaylistTracks(
        userObj,
        playlistTracks
      );
      // Update data fields if we add tracks
      playlistData.snapshot_id = snapshotId;
      playlistData.track_count = newTrackCount;
    }
    const playlist = await PlaylistModel1.create(playlistData);
    await PlaylistModel1.addPlaylists([playlistTracks], true);
    return playlist;
  }

  return PlaylistModel1.create(playlistData);
};
exports.update = async (userObj, id, data) => {
  const { type, label_id } = await PlaylistModel1.getOne(id);

  // Changing the playlist type comes with multiple side-effects
  switch (data.type) {
    case 'untracked': {
      if (type === 'label') {
        // Remove playlist-label assoc
        data.label_id = null;
      }
      // Remove playlist-tracks associations (but leave tracks)
      await PlaylistModel1.removePlaylistTracks(id);
      break;
    }
    case 'mix': {
      const tracks = await TracksService.getPlaylistTracks(userObj, id, true);
      if (type === 'label') {
        // Remove playlist-label assoc
        data.label_id = null;
      }
      // sync/import
      await TrackModel1.addTracks(tracks);
      await PlaylistModel1.addPlaylists([{ playlist_id: id, tracks }], true);
      break;
    }
    case 'label': {
      const tracks = await TracksService.getPlaylistTracks(id, true);
      if (type === 'label' && data.label_id) {
        // Remove prev label from tracks and add new one
        await LabelModel1.removeLabelTracks(label_id);
      }
      // sync/import
      await TrackModel1.addTracks(tracks);
      await PlaylistModel1.addPlaylists([{ playlist_id: id, tracks }], true);
      await LabelModel1.addLabels([
        { label_id: data.label_id, track_ids: tracks.map(t => t.id) },
      ]);

      // Add all tracks with label_id (not in playlist) to playlist
      const labelTracks = await LabelModel1.getTracks(data.label_id);
      if (labelTracks.length) {
        const newPlaylistTracks = {
          playlist_id: id,
          track_ids: labelTracks,
        };
        const [snapshotId, newTrackCount] = await addPlaylistTracks(
          userObj,
          newPlaylistTracks
        );
        data.snapshot_id = snapshotId;
        data.track_count = newTrackCount;
        await PlaylistModel1.addPlaylists([newPlaylistTracks], true);
      }
      break;
    }
  }
  // Spotify request
  if (data.name || data.description) {
    await request.put({
      url: 'https://api.spotify.com/v1/playlists/' + id,
      headers: { Authorization: 'Bearer ' + userObj.accessToken },
      body: {
        ...(data.name && { name: data.name }),
        ...(data.description && { description: data.description }),
      },
      json: true,
    });
  }
  return PlaylistModel1.update(id, data);
};
exports.delete = async (userObj, id) => {
  await request.delete({
    url: 'https://api.spotify.com/v1/playlists/' + id + '/followers',
    headers: { Authorization: 'Bearer ' + userObj.accessToken },
    json: true,
  });
  await PlaylistModel1.removePlaylistTracks(id);
  await PlaylistModel1.updateMany([{ id, type: 'deleted', label_id: null }]);

  return PlaylistModel1.getOne(id);
};
exports.restore = async (userObj, id) => {
  await request.put({
    url: 'https://api.spotify.com/v1/playlists/' + id + '/followers',
    headers: { Authorization: 'Bearer ' + userObj.accessToken },
    json: true,
  });
  await PlaylistModel1.updateMany([{ id, type: 'untracked' }]);
  // TODO: remove this and put it in track controller
  return PlaylistModel1.getOne(id);
};

// ============== TODO: Playlist handle LOCAL-SPOTIFY syncing
exports.syncTracks = async (userObj, id) => {
  const { type, label_id } = await PlaylistModel1.getOne(id);
  const tracks = await TracksService.getPlaylistTracks(userObj, id, true);

  const associations = [
    {
      playlist_id: id,
      tracks,
      ...(label_id && {
        label_id: label_id,
        track_ids: tracks.map(t => t.id),
      }),
    },
  ];
  await TrackModel1.addTracks(tracks);
  if (type !== 'untracked') {
    await PlaylistModel1.addPlaylists(associations, true);
    if (type === 'label') {
      await LabelModel1.removeLabelTracks(label_id);
      await LabelModel1.addLabels(associations);
    }
  }
  await PlaylistModel1.updateMany([{ id, updates: 0 }]);
  return PlaylistModel1.getOne(id);
};
exports.revertTracks = async (userObj, playlistId) => {
  const trackIds = await PlaylistModel1.getTracks(playlistId);
  let uris = trackIds.map(id => 'spotify:track:' + id);

  let replace = true; // first 100 tracks use the replace endpoint
  let snapshotId;
  while (uris.length) {
    const batch = uris.splice(0, 100);
    const options = {
      url: 'https://api.spotify.com/v1/playlists/' + playlistId + '/tracks',
      headers: { Authorization: 'Bearer ' + userObj.accessToken },
      body: { uris: batch },
      json: true,
    };
    if (replace) {
      const response = await request.put(options);
      snapshotId = response.snapshot_id;
      replace = false;
    } else {
      const response = await request.post(options);
      snapshotId = response.snapshot_id;
    }
  }
  await PlaylistModel1.updateMany([
    {
      id: playlistId,
      updates: 0,
      track_count: trackIds.length,
      snapshot_id: snapshotId,
    },
  ]);
  return PlaylistModel1.getOne(playlistId);
};

// Helpers
/**
 * Handle adding/removing tracks in Spotify playlist.
 * @param {UserObj} userObj
 * @param {PlaylistTrackIds} data
 * @param {boolean=} remove - Default false, pass true to reverse operation.
 * @returns {Promise<PlaylistUpdates>}
 */
const updateSpotifyPlaylistTracks = async (
  userObj,
  { playlist_id, track_ids },
  remove = false
) => {
  const trackUris = track_ids.map(id => `spotify:track:${id}`);
  const url = `https://api.spotify.com/v1/playlists/${playlist_id}/tracks`;
  const headers = {
    Authorization: 'Bearer ' + userObj.accessToken,
  };
  let snapshot_id;
  const chunks = chunkArray(trackUris, 100);
  for (const chunk of chunks) {
    const { data } = await axios({
      url,
      method: remove ? 'delete' : 'post',
      data: { uris: chunk },
      headers,
    });
    snapshot_id = data.snapshot_id;
  }
  // TODO! snapshot_id might be undefined (v2 had a check for this)
  return {
    id: playlist_id,
    snapshot_id,
    track_count_delta: track_ids.length * (remove ? -1 : 1),
  };
};
/**
 * Remove duplicate tracks from Spotify playlist.
 * @param {UserObj} userObj
 * @param {string} id - playlistId
 * @param {string[]=} trackIds - Optional, for avoiding more Spotify requests.
 */
const removePlaylistDuplicates = async (userObj, id, trackIds) => {
  // TODO!, use this when updating playlist to tracked or when syncing
  // a single playlist
};
